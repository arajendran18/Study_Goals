"""
ESMS Automated Access Keys Rotation: Execute ESMS Validation Script

Step Functions
--------------
Workflow: lllaws-esms-jit-backend-job-{env}
Step #: 5

Description
----------
This lambda will execute on AWS accounts where Access Keys have been rotated. It validates the authentication between AWS Account and Secret Mount is valid. 

Parameters
----------
(none)

Returns
-------
  event['Input']
"""

import boto3
import json
import base64
import requests
import logging
import os
from botocore.auth import SigV4Auth
from botocore.awsrequest import AWSRequest
from botocore.session import get_session

LOG_LEVEL = os.environ['LOG_LEVEL']
LOGGER = logging.getLogger()
if LOG_LEVEL == 'log_level':
    LOGGER.setLevel(LOG_LEVEL)
    LOGGER.info("Log level set to %s" % LOGGER.getEffectiveLevel())
else:
    LOGGER.setLevel(logging.ERROR)
logging.getLogger('boto3').setLevel(logging.CRITICAL)
logging.getLogger('botocore').setLevel(logging.CRITICAL)

# Vault URLs for Non-Prod and Prod environments
VAULT_NPD_URL = 'https://npd-esms.lllint.com'
VAULT_PRD_URL = 'https://prd-esms.lllint.com'

# Vault IAM Auth roles for Non-Prod and Prod environments
VAULT_NPD_ROLE = 'esms-npd-lambda-aws-secret-validation'
VAULT_PRD_ROLE = 'esms-prd-lambda-aws-secret-validation'


def sign_vault_iam_request(vault_url, vault_aws_auth_role):
    """Authenticate to Vault using AWS IAM Authentication."""
    session = get_session()
    credentials = session.get_credentials()
    region = 'us-east-1'  # Update with your AWS region

    # Create the STS request
    request = AWSRequest(
        method='POST',
        url='https://sts.amazonaws.com/',
        data='Action=GetCallerIdentity&Version=2011-06-15',
        headers={'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8'}
    )

    # Sign the request using SigV4
    SigV4Auth(credentials, 'sts', region).add_auth(request)

    signed_headers = dict(request.headers)
    signed_request_body = request.body
    encoded_body = base64.b64encode(signed_request_body).decode('utf-8')

    # Vault login request
    login_data = {
        'role': vault_aws_auth_role,
        'iam_http_request_method': 'POST',
        'iam_request_url': base64.b64encode(b'https://sts.amazonaws.com').decode('utf-8'),
        'iam_request_body': encoded_body,
        'iam_request_headers': base64.b64encode(json.dumps(signed_headers).encode('utf-8')).decode('utf-8')
    }

    response = requests.post(f'{vault_url}/v1/auth/aws/login', json=login_data)

    if response.status_code == 200:
        return response.json()['auth']['client_token']
    else:
        raise Exception(f"Vault Authentication Failed: {response.text}")


def check_mount_path_exists(vault_url, vault_token, mount_path):
    """Check if the specified mount path exists in Vault."""
    headers = {
        'X-Vault-Token': vault_token
    }

    # List all mount paths
    response = requests.get(f'{vault_url}/v1/sys/mounts', headers=headers)

    if response.status_code == 200:
        mounts = response.json()
        # Check if the mount path exists in the available mounts
        if f"{mount_path}/" in mounts:
            return True
        else:
            return False
    else:
        raise Exception(f"Error listing mount paths: {response.text}")


def generate_aws_credentials(vault_url, vault_token, mount_path, aws_secret_engine_role):
    """Generate AWS credentials using the Vault AWS secret engine."""
    headers = {
        'X-Vault-Token': vault_token
    }

    # Check if the mount path exists
    if check_mount_path_exists(vault_url, vault_token, mount_path):
        # If mount path exists, generate AWS credentials
        response = requests.get(f'{vault_url}/v1/{mount_path}/creds/{aws_secret_engine_role}', headers=headers)

        if response.status_code == 200:
            data = response.json()
            access_key = data['data']['access_key'].strip()
            secret_key = data['data']['secret_key'].strip()
            return access_key, secret_key
        else:
            raise Exception(f"Error generating AWS credentials: {response.text}")
    else:
        # If mount path does not exist, print an error message
        LOGGER.info(f"This account '{mount_path}' is not available in '{vault_url}' AWS secret engine")
        return None, None


def validate_credentials_in_both_environments(mount_path, aws_secret_engine_role):
    """Check for mount path in NPD, then PRD environment, and generate AWS credentials."""
    try:
        # Authenticate to NPD Vault
        npd_vault_token = sign_vault_iam_request(VAULT_NPD_URL, VAULT_NPD_ROLE)
        access_key, secret_key = generate_aws_credentials(VAULT_NPD_URL, npd_vault_token, mount_path, aws_secret_engine_role)

        if access_key and secret_key:
            LOGGER.info(f"Credentials generated from NPD environment for mount path: {mount_path}")
            return access_key, secret_key
        else:
            # Try in PRD environment if not found in NPD
            prd_vault_token = sign_vault_iam_request(VAULT_PRD_URL, VAULT_PRD_ROLE)
            access_key, secret_key = generate_aws_credentials(VAULT_PRD_URL, prd_vault_token, mount_path, aws_secret_engine_role)

            if access_key and secret_key:
                LOGGER.info(f"Credentials generated from PRD environment for mount path: {mount_path}")
                return access_key, secret_key
            else:
                LOGGER.info(f"Mount path '{mount_path}' not found in both NPD and PRD environments.")
                return None, None

    except Exception as e:
        LOGGER.error(f"Error during validation: {str(e)}")
        return None, None


def lambda_handler(event, context):
    # Read JSON payload input to fetch the secret engines
    aws_mount_paths = event["Input"]["SecretEngines"]

    # Default role is used for generating access credentials
    aws_secret_engine_role = 'readonly'

    try:
        # Generate AWS credentials from each AWS secret engine
        for mount_path in aws_mount_paths:
            access_key, secret_key = validate_credentials_in_both_environments(mount_path, aws_secret_engine_role)

            # Validate if AWS credentials are generated
            if access_key and secret_key:
                LOGGER.info(f"Access Key and Secret key successfully generated for mount path: {mount_path}")
            else:
                LOGGER.info(f"Failed to generate AWS credentials for mount path: {mount_path}")

        event['Input']['SecretValidationResponse'] = 'AWS Secret Engine validation completed.'
        return event['Input']

    except Exception as e:
        LOGGER.error(f"Validation script failed with error: {str(e)}")
        return {'statusCode': 500, 'body': f"Validation script failed with error: {str(e)}"}
