import boto3
from datetime import datetime, timedelta

# Initialize CloudWatch client
cloudwatch = boto3.client('cloudwatch')

def get_http_metrics(start_time, end_time, load_balancer_name):
    response = cloudwatch.get_metric_data(
        MetricDataQueries=[
            {
                'Id': 'http2xx',
                'MetricStat': {
                    'Metric': {
                        'Namespace': 'AWS/ApplicationELB',
                        'MetricName': 'HTTPCode_ELB_2XX_Count',
                        'Dimensions': [{'Name': 'LoadBalancer', 'Value': load_balancer_name}]
                    },
                    'Period': 3600,
                    'Stat': 'Sum'
                },
                'ReturnData': True
            },
            {
                'Id': 'http3xx',
                'MetricStat': {
                    'Metric': {
                        'Namespace': 'AWS/ApplicationELB',
                        'MetricName': 'HTTPCode_ELB_3XX_Count',
                        'Dimensions': [{'Name': 'LoadBalancer', 'Value': load_balancer_name}]
                    },
                    'Period': 3600,
                    'Stat': 'Sum'
                },
                'ReturnData': True
            },
            {
                'Id': 'http4xx',
                'MetricStat': {
                    'Metric': {
                        'Namespace': 'AWS/ApplicationELB',
                        'MetricName': 'HTTPCode_ELB_4XX_Count',
                        'Dimensions': [{'Name': 'LoadBalancer', 'Value': load_balancer_name}]
                    },
                    'Period': 3600,
                    'Stat': 'Sum'
                },
                'ReturnData': True
            },
            {
                'Id': 'http5xx',
                'MetricStat': {
                    'Metric': {
                        'Namespace': 'AWS/ApplicationELB',
                        'MetricName': 'HTTPCode_ELB_5XX_Count',
                        'Dimensions': [{'Name': 'LoadBalancer', 'Value': load_balancer_name}]
                    },
                    'Period': 3600,
                    'Stat': 'Sum'
                },
                'ReturnData': True
            }
        ],
        StartTime=start_time,
        EndTime=end_time,
        ScanBy='TimestampDescending'
    )
    return response

def lambda_handler(event, context):
    # Set the time range for the last 30 days
    start_time = datetime.utcnow() - timedelta(days=30)
    end_time = datetime.utcnow()

    # Ensure to set the correct load balancer name
    load_balancer_name = 'app/my-load-balancer/12345abcdef'  # Change this to your actual Load Balancer ID

    # Get the HTTP metrics
    metrics_data = get_http_metrics(start_time, end_time, load_balancer_name)

    # Extract the values
    http_2xx_count = sum(metrics_data['MetricDataResults'][0]['Values'])
    http_3xx_count = sum(metrics_data['MetricDataResults'][1]['Values'])
    http_4xx_count = sum(metrics_data['MetricDataResults'][2]['Values'])
    http_5xx_count = sum(metrics_data['MetricDataResults'][3]['Values'])

    # Calculate total requests and errors
    total_requests = http_2xx_count + http_3xx_count + http_4xx_count + http_5xx_count
    total_errors = http_4xx_count + http_5xx_count

    # Calculate availability percentage
    if total_requests > 0:
        availability_percentage = (1 - (total_errors / total_requests)) * 100
    else:
        availability_percentage = 0

    # Construct the response
    result = {
        "2xx_count": http_2xx_count,
        "3xx_count": http_3xx_count,
        "4xx_count": http_4xx_count,
        "5xx_count": http_5xx_count,
        "total_requests": total_requests,
        "total_errors": total_errors,
        "availability_percentage": availability_percentage
    }

    return {
        'statusCode': 200,
        'body': result
    }
